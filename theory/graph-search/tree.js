// note: 트리란? 
// note:   그래프의 특수한 조건 3개중 2개를 만족하는 형태이다
// note:     1. 모든 정점이 연결 되어있어야함
// note:     2. 그래프에서 사이클이 존재하지 않아야함
// note:     3. 정점 개수( |V| ) = 간선 개수( |E| ) + 1 와 동일해야한다.

// note: Rooted Tree (보통 Rooted Tree로 이용하여 문제를 푼다)
// note:     node = vertex (정점), root(최상위 정점), depth = root간 깊이 (0, 1, 2 [1부터 시작해도 상관없음]), 
// note:     parent(부모), child(자식), ancestor(조상), sibling(형제 노드), leaf node(잎)

// note: 트리 문제인지 알 수 있는 키워드
// note:   1. 모든 두 정점 사이에 이들을 잇는 경로가 존재하면서, 사이클이 존재하지 않는 경우만 고려한다
// note:   2. 마을과 마을 사이를 직접 있는 n -1 개의 길이 있으며 모든 마을은 연결 되어있다
// note:   3. 문제는 일반적 그래프가 아니라 트리이다(연결되어 있고 사이클이 없는 그래프)

// note: 트리를 저장 하는 방법
// todo:   1.공간 복잡도 이슈 때문에 보통은 '인접 리스트'를 이용한다. 
// todo:     왜냐하면 트리의 정의에서 처럼 "정점의 개수 = 간선 + 1"의 개수이기 때문에 인접리스트로 트리를 저장하면 O(E)로 저장이 가능하다. // 인접 행렬은 O(V^2)이다.  만약 V가 10만개면 개수가 엄청 차이난다.
// todo:   2.가중치 그래프에서는 인접 행렬은 '1' 대신 가중치 값을 넣는다.
// todo:                         인접 리스트에서는 객체[Node, 가중치]를 넣는다.

// note: 문제의 핵심
// note:   1. 정점 & 간선에 대한 정확한 정의가 필요하다
// note:     (주어지는 그래프는 변형해서 인접 리스트를 만들어야할 수도 있고 그냥 그것을 잘 활용해서 문제를 풀어야할 수 도 있다)
// note:   2. 트리의 특성을 이용하여 부모를 구하거나, 조상을 구하거나, 리프 노드, 형제를 구할 수도 있다
// todo:   3. 대부분 DFS 를 사용하는 것이 좋다. 트리는 DFS로 푼다라고 외우자!!
// note:     서브 트리 개념을 이용하여 DP를 사용 할 수 있기 때문에 DFS를 사용하는 것이 좋다
// note:   4. DFS, BFS를 활용하지 않고 그냥 트리의 특성을 이용하여 풀어야 하는 문제도 있다.


// note: 내가 알게 된것
// note:   1. 트리는 사이클이 존재하지않아서 방문체크를 안해도 중복된 노드를 가지 않는다. 
// note:      (조건. 양 방향 그래프는 방문 체크 해야함)
// note:   2. 트리는 DFS로도 충분히 깊이를 구할 수 있다.
// todo:   3. 트리에서는 DFS로 깊이, 거리, 지름 등을 구하지 않으면 시간 초과 날 수 있다. (BOJ 1167)
// note:   4. 트리에서 사이클이 존재하는지 판단하려면 DFS를 사용해야한다.